#!/usr/bin/env python3


import os, sys, logging, time, pprint, warnings, argparse, re, configparser, shutil, imaplib, email, email.header, email.utils, string, subprocess, uuid
import pprint
import select
from subprocess import PIPE, Popen
from threading  import Thread
import curses
from curses import wrapper
import socket

warnings.filterwarnings('ignore')
ME = os.path.basename(sys.argv[0])
loggingFormat='%(asctime)s %(filename)s: %(message)s'
logging.basicConfig(stream=sys.stderr, level=logging.WARNING, format=loggingFormat)
logger = logging.getLogger(ME)
start_time = time.time()
maxLoopCounter=-1
pingMissAmberThreshold = 3


parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter) #, epilog=configFileHelp)
parser.add_argument("-v", "--verbose",  help="increase output verbosity", action="store_true")
parser.add_argument("-D", "--debug",    help="enable debugging output", action="store_true")
parser.add_argument("-4", "--ipv4",     help="Limit name resolution to ipv4 (fping)", action="append_const", dest='fpingOptions', const='-4')
parser.add_argument("-6", "--ipv6",     help="Limit name resolution to ipv6 (fping)", action="append_const", dest='fpingOptions', const='-6')
parser.add_argument("-d", "--rdns",     help="Use DNS to lookup address of return ping packet. (fping)", action="append_const", dest='fpingOptions', const='-d')
parser.add_argument("-g", "--generate", help="Generate target list using supplied mask or pattern (fping)", action="store", type=str)
parser.add_argument("-p", "--period",   help="The time in milliseconds that fping waits between successive packets, default 100 (fping)", action="store", type=int, default=100)
parser.add_argument("-r", "--refresh",  help="Time between screen refresh, Accepts whole decimal seconds", action="store", type=int, default=1)
parser.add_argument("fping_args", help="Remainder of arguments passed to fping", nargs='*')
args = parser.parse_args()

stdscr = curses.initscr()
curses.start_color()
colorPairWarning = 1
colorPairError = 2
colorPairOk = 3
curses.init_pair(colorPairWarning, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Amber warning
curses.init_pair(colorPairError,   curses.COLOR_RED,    curses.COLOR_BLACK)  # Red is bad
curses.init_pair(colorPairOk,      curses.COLOR_GREEN,  curses.COLOR_BLACK)  # Green is good

if args.verbose:
    logger.setLevel(logging.INFO)
if args.debug:
    logger.setLevel(logging.DEBUG)

def bomb(chunk):
    logger.error("\n\n\n%s\n\n\n",chunk)
    sys.exit(1)


def enqueue_output(out, queue):
    for line in iter(out.readline, b''):
        queue.put(line)
        out.close()

def split_ip(ip):
    """Split a IP address given as string into a 4-tuple of integers."""
    return tuple(int(part) for part in ip.split('.'))

def sort_ip(x):
    if re.match("^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$",x):
        # Im and IP
        out=[]
        for o in x.split('.'):
            out.append("{:03d}".format(int(o)))
        return(".".join(out))
    else:
        return x
def cursesMain(stdscr):

    fpingCommand=[]
    fpingCommand.extend(['fping','-l'])
    if args.fpingOptions: 
        fpingCommand.extend(args.fpingOptions)
    if args.generate:
        fpingCommand.extend(['-g',args.generate])
    if args.period:
        fpingCommand.extend(['-p',str(args.period)])
    if args.fping_args:
        fpingCommand.extend(args.fping_args)

    stdscr.addstr(0,0,"Command: {}".format(" ".join(fpingCommand)))
    stdscr.refresh()
    time.sleep(1)
    p = Popen(fpingCommand,stdout=PIPE, stderr=PIPE)
    #p = Popen(['fping','--rdns','-p','100','-l','-g','192.168.200.0/24'],stdout=PIPE, stderr=PIPE)
    selStdout = select.poll()
    selStderr = select.poll()
    selStdout.register(p.stdout,select.POLLIN)
    selStderr.register(p.stderr,select.POLLIN)

    # ... do other things here
    loopCounter = 0
    lines = []
    results = {}
    lastResults = {}
    resultsMissCtr = {}
    state = {}
    oddlines = []
    hostLabelLength = 0
    lastRefresh = time.time()
    displayCols = 1

    while loopCounter != maxLoopCounter:
        now = time.time()
        #logger.debug("LOOP ctr[{}] max[{}]".format(loopCounter,maxLoopCounter))
        if selStdout.poll(1):
            lines.extend(p.stdout.readline().decode().splitlines())
        elif selStderr.poll(1):
            lines.extend(p.stderr.readline().decode().splitlines())
    #    else:
    #        print('.',end='')

        for line in lines:
            #print("line[{}]".format(line))
            if re.search('ICMP.*nreachable', line):
                # Special case for unreachable, last word is host spec
                m = line.split()
                host = m[-1]
                results[host] = " ".join(m[0:3]) # line #"ICMP Host Unreachable"
                state[host] = "DOWN"
            elif re.search(':',line):
                # Normal Line
                (host,message) = line.split(':',2)
                host=host.strip()
                message=message.strip()
                results[host] = message
                state[host] = "up"
            else:
                oddlines.append(line)

        if ( time.time() - lastRefresh ) > args.refresh:
            lastRefresh = time.time()
            # display stuff
            if results.keys():
                hostLabelLength = len(max(results.keys(),key=len))
            stdscr.clear()
            lines.clear()
            lctr = 0
            colCtr = 0
            colWidth = int(curses.COLS / displayCols)  # Column width
            for host in sorted(results.keys(),key=sort_ip):
                myLineCol = colCtr * colWidth
                thisResult = results[host]
                
                stdscr.addstr(lctr,myLineCol+hostLabelLength+1,results[host].strip()[0:colWidth-(hostLabelLength+2)])
                if lastResults.get(host,"") == thisResult:   # Same data as last loop, count as a miss
                    resultsMissCtr+=1
                else:
                    resultsMissCtr=0 # clear
                if state[host] == "up":
                    if resultsMissCtr >= pingMissAmberThreshold:
                        stdscr.addstr(lctr,myLineCol+hostLabelLength+1,"miss {}, {}".format(resultsMissCtr,results[host].strip())[0:colWidth-(hostLabelLength+2)])
                        stdscr.addstr(lctr,myLineCol,"{:>{}}".format(host,hostLabelLength),curses.color_pair(colorPairWarning))
                    else:
                        stdscr.addstr(lctr,myLineCol,"{:>{}}".format(host,hostLabelLength),curses.color_pair(colorPairOk))
                if state[host] == "DOWN":  # hard down
                    stdscr.addstr(lctr,myLineCol,"{:>{}}".format(host,hostLabelLength),curses.color_pair(colorPairError))
                lastResults[host]=thisResult
                lctr+=1
                if lctr >= curses.LINES:
                    colCtr+=1
                    lctr=0
                    if colCtr >= displayCols:
                        displayCols+=1
                        break
                #db(stdscr,"lctr[{}] colCtr[{}] myLineCol[{}] colWidth[{}] {}x{}".format(lctr, colCtr, myLineCol, colWidth, curses.LINES, curses.COLS))
                    
            #for odd in sorted(oddlines):
            #    print("odd:\t{}".format(odd))
            #    stdscr.addstr(lctr,myLineCol,"odd: "+odd)
            #    lctr+=1
            #    if lctr >= curses.LINES:
            #        colCtr+=1
            #        lctr=1
            #        if colCtr >= displayCols:
            #            displayCols+=1
            #            break
            stdscr.refresh()
            time.sleep(.1)
            

        # read line without blocking
    #    try:  line = q.get_nowait() # or q.get(timeout=.1)
        #try:  line = q.get(timeout=.1)
    #    except Empty:
    #        pass
            #print('.', end='')
    #    else: # got line
    #        # ... do something with line
        loopCounter += 1

wrapper(cursesMain)


