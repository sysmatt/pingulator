#!/usr/bin/env python3


import os, sys, logging, time, pprint, warnings, argparse, re, configparser, shutil, imaplib, email, email.header, email.utils, string, subprocess, uuid
import pprint
import select
from subprocess import PIPE, Popen
from threading  import Thread
import curses
from curses import wrapper

from queue import Queue, Empty

warnings.filterwarnings('ignore')
ME = os.path.basename(sys.argv[0])
loggingFormat='%(asctime)s %(filename)s: %(message)s'
logging.basicConfig(stream=sys.stderr, level=logging.WARNING, format=loggingFormat)
logger = logging.getLogger(ME)
start_time = time.time()
maxLoopCounter=-1


stdscr = curses.initscr()
curses.start_color()
colorPairWarning = 1
colorPairError = 2
colorPairOk = 3
curses.init_pair(colorPairWarning, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Amber warning
curses.init_pair(colorPairError,   curses.COLOR_RED,    curses.COLOR_BLACK)  # Red is bad
curses.init_pair(colorPairOk,      curses.COLOR_GREEN,  curses.COLOR_BLACK)  # Green is good
parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter) #, epilog=configFileHelp)
parser.add_argument("-v", "--verbose",  help="increase output verbosity", action="store_true")
parser.add_argument("-d", "--debug",    help="enable debugging output", action="store_true")
#parser.add_argument("-C", "--clear",   help="clear out pending messages upon startup before processing", action="store_true")
parser.add_argument("-o", "--oneshot",  help="process account(s) only once then exit", action="store_true")
parser.add_argument("-4", "--ipv4",     help="Limit name resolution to ipv4 (fping)", action="store_true")
parser.add_argument("-6", "--ipv6",     help="Limit name resolution to ipv6 (fping)", action="store_true")
parser.add_argument("-n", "--numloops", help="process account(s) this many times then exit", action="store", type=int)
#parser.add_argument("-c", "--cols",    help="Number of columns to display", action="store", type=int, default=1)
parser.add_argument("-g", "--generate", help="Generate target list using supplied mask or pattern (fping)", action="store", type=str)
parser.add_argument("-r", "--refresh",  help="Time between screen refresh, Accepts whole decimal seconds", action="store", type=int, default=1)
#parser.add_argument("configFile",    help="provide a ini configuration file", action="store")
args = parser.parse_args()

# Holder of imap connection objects

if args.verbose:
    logger.setLevel(logging.INFO)
if args.debug:
    logger.setLevel(logging.DEBUG)
if args.oneshot:
    maxLoopCounter = 1
    logger.debug("Oneshot mode")
if args.numloops:
    maxLoopCounter = int(args.numloops)
    logger.debug("Limit to [{}] loops".format(maxLoopCounter))

def bomb(chunk):
    logger.error("\n\n\n%s\n\n\n",chunk)
    sys.exit(1)


def enqueue_output(out, queue):
    for line in iter(out.readline, b''):
        queue.put(line)
        out.close()

def cursesMain(stdscr):

    def db(stdscr,x):
        stdscr.addstr(20,100,x)
        stdscr.refresh()

    p = Popen(['fping','-p','100','-l','-g','192.168.200.0/25'],stdout=PIPE, stderr=PIPE)
    selStdout = select.poll()
    selStderr = select.poll()
    selStdout.register(p.stdout,select.POLLIN)
    selStderr.register(p.stderr,select.POLLIN)

    # ... do other things here
    loopCounter = 0
    lines = []
    results = {}
    lastResults = {}
    state = {}
    oddlines = []
    hostLabelLength = 0
    lastRefresh = time.time()
    displayCols = 1

    while loopCounter != maxLoopCounter:
        now = time.time()
        #logger.debug("LOOP ctr[{}] max[{}]".format(loopCounter,maxLoopCounter))
        if selStdout.poll(1):
            lines.extend(p.stdout.readline().decode().splitlines())
        elif selStderr.poll(1):
            lines.extend(p.stderr.readline().decode().splitlines())
    #    else:
    #        print('.',end='')

        for line in lines:
            #print("line[{}]".format(line))
            if re.search('ICMP.*nreachable', line):
                # Special case for unreachable, last word is host spec
                m = line.split()
                host = m[-1]
                results[host] = " ".join(m[0:3]) # line #"ICMP Host Unreachable"
                state[host] = "DOWN"
            elif re.search(':',line):
                # Normal Line
                (host,message) = line.split(':',2)
                host=host.strip()
                message=message.strip()
                results[host] = message
                state[host] = "up"
            else:
                oddlines.append(line)

        if ( time.time() - lastRefresh ) > args.refresh:
            lastRefresh = time.time()
            # display stuff
            if results.keys():
                hostLabelLength = len(max(results.keys(),key=len))
            stdscr.clear()
            lines.clear()
            lctr = 1
            colCtr = 0
            colWidth = int(curses.COLS / displayCols)  # Column width
            for host in sorted(results):
                #print("{}:\t{}".format(host,results[host]))
                myLineCol = colCtr * colWidth
                thisResult = results[host]
                if state[host] == "up":
                    stdscr.addstr(lctr,myLineCol+hostLabelLength+1,state[host],curses.color_pair(colorPairOk))
                    if lastResults.get(host,"") == thisResult:
                        # no update
                        state[host] = "????" # Not sure... its a warning
                if state[host] == "????":
                    stdscr.addstr(lctr,myLineCol+hostLabelLength+1,state[host], curses.color_pair(colorPairWarning))
                if state[host] == "DOWN":
                    stdscr.addstr(lctr,myLineCol+hostLabelLength+1,state[host], curses.color_pair(colorPairError))
                stdscr.addstr(lctr,myLineCol,"{:>{}}".format(host,hostLabelLength))
                stdscr.addstr(lctr,myLineCol+hostLabelLength+6,results[host])
                lastResults[host]=thisResult
                lctr+=1
                if lctr >= curses.LINES:
                    colCtr+=1
                    lctr=1
                    if colCtr >= displayCols:
                        displayCols+=1
                        break
                db(stdscr,"lctr[{}] colCtr[{}] myLineCol[{}] colWidth[{}] {}x{}".format(lctr, colCtr, myLineCol, colWidth, curses.LINES, curses.COLS))
                    
            for odd in sorted(oddlines):
                print("odd:\t{}".format(odd))
                stdscr.addstr(lctr,myLineCol,"odd: "+odd)
                lctr+=1
                if lctr >= curses.LINES:
                    colCtr+=1
                    lctr=1
                    if colCtr >= displayCols:
                        displayCols+=1
                        break
            stdscr.refresh()
            

        # read line without blocking
    #    try:  line = q.get_nowait() # or q.get(timeout=.1)
        #try:  line = q.get(timeout=.1)
    #    except Empty:
    #        pass
            #print('.', end='')
    #    else: # got line
    #        # ... do something with line
        loopCounter += 1

wrapper(cursesMain)


